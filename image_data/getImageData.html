<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Get Image Data</title>
</head>
<body>
	<canvas width="1600px" height="1200px" style="border: 1px solid #000;box-shadow: 2px 2px 3px #000"></canvas>
	<div id="log" style="width: 1600px; height: 1200px; overflow-y: scroll;"></div>
	<script>
		var canvas = document.querySelector('body canvas'),
			ctx = canvas.getContext('2d'),
			image = new Image();
        
        var width = canvas.width/4;
        var height = canvas.height/3;

		image.onload = function (){
			ctx.drawImage(image, 0, 0, width, height);		
		}
		image.src = '10.jpg';
		
        var index = 1;
		canvas.onclick = function() {
			if (index > 11) {
				return;
			};
			var imagedata = ctx.getImageData(0, 0, width, height),
			pixs = imagedata.data;

			switch(index) {
				case 1: Revert(pixs); break;
				case 2: Trash(pixs); break;
				case 3: Sharp(pixs, width, 5); break;
				case 4: Gauss(pixs, width, height, 3, 3); break;
				case 5: Noise(pixs, width, height, 50); break;
				case 6: Dotted(pixs, width, height, 3, 3); break;
                case 7: Fudiao(pixs, width, height); break;
                case 8: {
                    // Revert(pixs);
                    AlphaConvert(pixs, width, height, function(width, height, x, y) {
                        var cx = width >> 1,
                            cy = height >> 1;
                        // return Math.sin(Math.pow(Math.pow(x - cx, 2) + Math.pow(y - cy, 2), 0.5)/Math.PI*0.5)/4 + 0.75;
                        return Math.log(Math.pow(Math.pow(x - cx, 2) + Math.pow(y - cy, 2), 0.5)/200 + 1);
                    });
                    break;
                }
                case 11: WaterWave(pixs, width, height, width/2, height/2, 10); break;
			}
			ctx.putImageData(imagedata, width*(index%4), height*(Math.floor(index/4)));
			index++;
		}

        function copyImageData(srcData, width, height) {
            var canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            var context = canvas.getContext('2d');
            var imgData = context.createImageData(width, height);
            imgData.data.set(srcData);
            return imgData.data;
        }

        function AlphaConvert(data, width, height, func) {
            for(var i = 0;i < width;i++) {
                for(var j = 0;j < height;j++) {
                    var index = (i + j*width) * 4;
                    var a = +func(width, height, i, j);
                    a = (a === a ? a : 1);
                    data[index] = data[index]* a;
                    data[index+1] = data[index+1]* a;
                    data[index+2] = data[index+2]* a;
                    data[index+3] = data[index+3]* a;
                }
            }
        }

        function WaterWave(data, width, height, cx, cy, A) {
            var _data = copyImageData(data, width, height);
            var sx = 0, sy = 0;
            for (var i = 0; i < width; i++) {
                for(var j = 0; j < height; j++) {
                    var index = (i + j * width) * 4;
                    var point = [i, j]
                    reCalcAB(width, height, cx, cy, i, j, point, A)
                    data[index] = BLIP(_data, point, 0)
                    data[index+1] = BLIP(_data, point, 1)
                    data[index+2] = BLIP(_data, point, 2)                
                }
            }

            function reCalcAB(width, height, imageCX, imageCY, x, y, point, A){
                A = A || 6;//波纹幅度
                var B = Math.PI/2;//波纹周期
                var y0 = 1.0*(y-imageCY);
                var x0 = 1.0*(x-imageCX);
                var theta0 = Math.atan2(y0,x0);//转化成角坐标
                var r0 = Math.sqrt(x0*x0+y0*y0);//初始半径
                var r1 = r0+ A*width*0.01*Math.sin(B*0.1*r0);//计算新的半径
                
                point[0] = imageCX + r1*Math.cos(theta0);
                point[1] = imageCY + r1*Math.sin(theta0);//转换后的坐标
                if(point[0]>width)
                    point[0] = width-1;
                else if(point[0]<0)
                    point[0] = 0;                //超出边界的处理
                if(point[1]>height)
                    point[1] = height-1;
                else if(point[1]<0)
                    point[1] = 0;
            }

            function BLIP(data, point, channel) {
                var a = point[0], b = point[1];
                var x = [], y = [];
                x.push(parseInt(point[0])); 
                y.push(parseInt(point[1]));
                x.push(x[0]+1)
                y.push(y[0]+1)

                var data1 = data[(x[0] + y[0] * width) * 4 + channel]
                var data2 = data[(x[1] + y[0] * width) * 4 + channel]
                var data3 = data[(x[0] + y[1] * width) * 4 + channel]
                var data4 = data[(x[1] + y[1] * width) * 4 + channel]

                if (Math.abs(a - x[0]) < 0.00001 && Math.abs(b- x[1]) < 0.00001) {
                    return data1
                }
                var dx = parseFloat(a-x[0]);//x轴的比例
                var dy = parseFloat(b-y[0]);//y轴的比例

                var DataTemp1 = data1*(1.0-dx) + data2*dx;
                var DataTemp2 = data3*(1.0-dx) + data4*dx;
                return DataTemp1*(1.0-dy) + DataTemp2*dy;//核心插值过程
            }
        }

        function Fudiao(data, width, height) {  
            var _data = copyImageData(data, width, height);
            for ( var x = 1; x < width-1; x++) {      
                for ( var y = 1; y < height-1; y++) {      
                    // Index of the pixel in the array      
                    var idx = (x + y * width) * 4;         
                    var bidx = ((x-1) + y * width) * 4;  
                    var aidx = ((x+1) + y * width) * 4;  
                      
                    // calculate new RGB value  
                    var nr = _data[aidx + 0] - _data[bidx + 0] + 128;  
                    var ng = _data[aidx + 1] - _data[bidx + 1] + 128;  
                    var nb = _data[aidx + 2] - _data[bidx + 2] + 128;  
                    nr = (nr < 0) ? 0 : ((nr >255) ? 255 : nr);  
                    ng = (ng < 0) ? 0 : ((ng >255) ? 255 : ng);  
                    nb = (nb < 0) ? 0 : ((nb >255) ? 255 : nb);  
                      
                    // assign new pixel value      
                    data[idx + 0] = nr; // Red channel      
                    data[idx + 1] = ng; // Green channel      
                    data[idx + 2] = nb; // Blue channel      
                    data[idx + 3] = 255; // Alpha channel      
                }  
            }
        }

		function Dotted(data, width, height, R, r) {
			var R = parseInt(R) || 1;
            //内小圆半径
            var r = parseInt(r) || 1;

            var xLength = R * 2 + 1;

            //构造距离模板
            var disTmlMatrix = [
            ];

            var r2 = r * r;
            for(var x = -R; x < R; x ++){

                for(var y = -R; y < R; y ++){
                    if((x * x + y * y) > r2){
                        disTmlMatrix.push([x, y]);
                    }
                }

            }

            var xyToIFun = (function(width){
                return function(x, y, z){
                    z = z || 0;
                    return (y * width + x) * 4 + z;
                };
            })(width);

            //将大于距离外面的透明度置为0
            for(var x = 0, n = parseInt(width / xLength); x < n; x ++){

                for(var y = 0, m = parseInt(height / xLength); y < m;y ++){
                    var middleX = parseInt((x + 0.5) * xLength);
                    var middleY = parseInt((y + 0.5) * xLength);

                    for(var i = 0; i < disTmlMatrix.length; i ++){
                        var dotX = middleX + disTmlMatrix[i][0];
                        var dotY = middleY + disTmlMatrix[i][1];

                        //data[(dotY * width + dotX) * 4 + 3] = 0;
                        data[xyToIFun(dotX, dotY, 3)] = 225;
                        data[xyToIFun(dotX, dotY, 2)] = 225;
                        data[xyToIFun(dotX, dotY, 0)] = 225;
                        data[xyToIFun(dotX, dotY, 1)] = 225;
                    }
                }

            }
		}

		function Noise(data, width, height, R) {
			R = R || 50;
            var xLength = R * 2 + 1;

            //区块
            for(var x = 0;x < width;x ++){

                for(var y = 0;y < height;y ++){
                    
                    var realI = y * width + x;
                    for(var j = 0;j < 3;j ++){
                        var rand = parseInt(Math.random() * R * 2) - R;
                        data[realI * 4 + j] += rand;
                    }

                }

            }
		}

		function Gauss(pixes, width, height, radius, sigma) {
            var gaussMatrix = [],
                gaussSum = 0,
                x, y,
                r, g, b, a,
                i, j, k, len;


            radius = Math.floor(radius) || 3;
            sigma = sigma || radius / 3;
            
            a = 1 / (Math.sqrt(2 * Math.PI) * sigma);
            b = -1 / (2 * sigma * sigma);
            //生成高斯矩阵
            for (i = 0, x = -radius; x <= radius; x++, i++){
                g = a * Math.exp(b * x * x);
                gaussMatrix[i] = g;
                gaussSum += g;
            
            }
            //归一化, 保证高斯矩阵的值在[0,1]之间
            for (i = 0, len = gaussMatrix.length; i < len; i++) {
                gaussMatrix[i] /= gaussSum;
            }
            //x 方向一维高斯运算
            for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                    r = g = b = a = 0;
                    gaussSum = 0;
                    for(j = -radius; j <= radius; j++){
                        k = x + j;
                        if(k >= 0 && k < width){//确保 k 没超出 x 的范围
                            //r,g,b,a 四个一组
                            i = (y * width + k) * 4;
                            r += pixes[i] * gaussMatrix[j + radius];
                            g += pixes[i + 1] * gaussMatrix[j + radius];
                            b += pixes[i + 2] * gaussMatrix[j + radius];
                            // a += pixes[i + 3] * gaussMatrix[j];
                            gaussSum += gaussMatrix[j + radius];
                        }
                    }
                    i = (y * width + x) * 4;
                    // 除以 gaussSum 是为了消除处于边缘的像素, 高斯运算不足的问题
                    // console.log(gaussSum)
                    pixes[i] = r / gaussSum;
                    pixes[i + 1] = g / gaussSum;
                    pixes[i + 2] = b / gaussSum;
                    // pixes[i + 3] = a ;
                }
            }
            //y 方向一维高斯运算
            for (x = 0; x < width; x++) {
                for (y = 0; y < height; y++) {
                    r = g = b = a = 0;
                    gaussSum = 0;
                    for(j = -radius; j <= radius; j++){
                        k = y + j;
                        if(k >= 0 && k < height){//确保 k 没超出 y 的范围
                            i = (k * width + x) * 4;
                            r += pixes[i] * gaussMatrix[j + radius];
                            g += pixes[i + 1] * gaussMatrix[j + radius];
                            b += pixes[i + 2] * gaussMatrix[j + radius];
                            // a += pixes[i + 3] * gaussMatrix[j];
                            gaussSum += gaussMatrix[j + radius];
                        }
                    }
                    i = (y * width + x) * 4;
                    pixes[i] = r / gaussSum;
                    pixes[i + 1] = g / gaussSum;
                    pixes[i + 2] = b / gaussSum;
                    // pixes[i] = r ;
                    // pixes[i + 1] = g ;
                    // pixes[i + 2] = b ;
                    // pixes[i + 3] = a ;
                }
            }
		}

		function Revert(pixs) {
			for(var i = 0, len = pixs.length;i < len;i += 4){
				pixs[i] = 255 - pixs[i];
				pixs[i+1] = 255 - pixs[i+1];
				pixs[i+2] = 255 - pixs[i+2];
			}
		}

		function Trash(pixs) {
			for(var i = 0, len = pixs.length;i < len;i += 4){
				if((i + 1) % 4){
                    pixs[i] = pixs[i] > 128 ? 255 : 0;
                }
            }
		}

		function Sharp(pixs, width, lamta) {
			for(var i = 0, len = pixs.length;i < len;i += 4){
				var ii = i / 4;
	            var row = parseInt(ii / width);
	            var col = ii % width;
	            if(row == 0 || col == 0) continue;

	            var A = ((row - 1) *  width + (col - 1)) * 4;
	            var B = ((row - 1) * width + col) * 4;
	            var E = (ii - 1) * 4;

	            for(var j = 0;j < 3;j ++){
	                var delta = pixs[i + j] - (pixs[B + j] + pixs[E + j] + pixs[A + j]) / 3;
	                pixs[i + j] += delta * lamta;
	            }
	        }
		}
	</script>
</body>
</html>